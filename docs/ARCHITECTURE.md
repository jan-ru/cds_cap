# Architecture Documentation

## System Overview

This is a **dual-repository financial analytics system** built on SAP Cloud Application Programming Model (CAP) with an integrated dbt data transformation pipeline.

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                     Data Ingestion Layer                        │
│  Raw CSV/Excel Files → dbt Staging Models (DuckDB)              │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                  Data Transformation Layer                      │
│  dbt Intermediate → dbt Marts → SQLite Export                   │
│  (Revenue classification, P&L, Balance Sheet)                   │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    Service Layer (CAP)                          │
│  OData V4 Services → Tree Builders → Analytical Functions       │
│  (/root/projects/cds_cap/srv/)                                  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                  Presentation Layer (Fiori)                     │
│  Fiori Elements Apps (Analytical List Page, List Report)        │
│  (/root/projects/cds_cap/app/)                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Repository Structure

- **cds_cap/** (this repository): SAP CAP backend + Fiori Elements frontend
- **dbt/** (sibling repository): dbt data transformation pipeline

**Shared Database**: `/root/projects/database/db.sqlite` (parent directory of both repos)

## Component Architecture

### 1. Data Layer

#### Database: SQLite
- **Location**: `/root/projects/database/db.sqlite`
- **Access**: Shared between dbt (write) and CAP (read)
- **Configuration**: `package.json` → `cds.requires.db.credentials.url`
- **Schema**: Generated by dbt models, reflected in `db/schema.cds`

#### CDS Data Model (`db/schema.cds`)
```
demo namespace:
  - FinancialStatements (P&L and Balance Sheet data)
  - RevenueAnalysis (Revenue classification by account)
  - WorkingCapital (AR, AP, inventory metrics)
  - Products, ProductGroups, SalesOrders, SalesInvoices
  - DeliveryNotes, ServiceAgreements
  - GeneralLedger (GL transaction details)
```

**Entity Types**:
- `@cds.persistence.table`: Direct mapping to dbt-generated SQLite tables
- Naming convention: `demo.EntityName` (CDS) → `demo_EntityName` (SQLite)
- **Read-only from CAP perspective**: Source of truth is dbt models

### 2. Service Layer

#### Analytics Service (`srv/analytics-service.cds`)

**Service Patterns**:

1. **Standard Entities** (CRUD + OData queries):
   ```cds
   entity FinancialStatements as projection on demo.FinancialStatements;
   entity RevenueAnalysis as projection on demo.RevenueAnalysis;
   ```

2. **Functions** (read-only, return JSON strings):
   ```cds
   function getFinancialTree(...) returns String;
   function getRevenueLTMTree(...) returns String;
   function getPivotTable(...) returns String;
   ```
   - Return hierarchical tree structures as JSON
   - Built server-side by tree builder utilities

3. **Actions** (state mutations):
   ```cds
   action saveSettings(...) returns String;
   action resetSettings(...) returns String;
   ```

#### Tree Builder Pattern

**Purpose**: Generate hierarchical financial statements with drill-down capabilities

**Key Implementations**:
- `srv/utils/financial-tree-builder.js` - P&L, Balance Sheet, Sales statements
- `srv/utils/revenue-tree-builder.js` - Revenue LTM (Last Twelve Months) analysis
- `srv/utils/pivot-tree-builder.js` - Dynamic pivot tables

**Tree Structure**:
```javascript
{
  level: 1,                    // Hierarchy depth (1=header, 2=group, 3=detail)
  drillState: "expanded",      // "expanded" | "collapsed" | "leaf"
  label: "Operating Revenue",
  amountA: 150000,            // Period A value
  amountB: 120000,            // Period B value (for comparison)
  watA: 75.5,                 // Percentage of total (Period A)
  watB: 68.2,                 // Percentage of total (Period B)
  children: [...]             // Nested tree nodes
}
```

**Revenue Classification** (critical sync point):
- Defined in `srv/config/constants.js`:
  ```javascript
  REVENUE_ACCOUNTS: {
    ONE_OFF: ['84', '85'],
    RECURRING: ['80', '86', '87', '88']
  }
  ```
- **Must match** `dbt/macros/categorize_revenue.sql`
- Used by both tree builders and dbt mart models

#### Utility Modules (`srv/utils/`)

- **logger.js**: Centralized logging with context
- **error-handler.js**: HTTP error formatting and status code mapping
- **period-utils.js**: Date range filtering (`isInPeriod()`)
- **tree-builder-common.js**: Shared tree building utilities
- **validation.js**: Input validation and sanitization

See [srv/utils/README.md](../srv/utils/README.md) for detailed documentation.

### 3. Presentation Layer

#### Fiori Elements Apps (`app/`)

**App Architecture**:
```
app/revenue-analysis/
├── webapp/
│   ├── manifest.json          # OData binding, routing, i18n
│   ├── annotations.cds        # UI annotations (tables, forms, filters)
│   ├── test/
│   │   ├── e2e/               # wdi5 E2E tests
│   │   ├── integration/       # OPA5 integration tests
│   │   └── unit/              # QUnit unit tests (deprecated)
├── ui5.yaml                   # UI5 tooling config
├── wdio.conf.js               # WebdriverIO config (extends base)
└── package.json
```

**UI Patterns**:
1. **Analytical List Page**: Real-time filtering, chart + table views
2. **List Report**: Standard CRUD with search and navigation
3. **Object Page**: Detail view with facets and sections

**No Custom Controllers**: Pure Fiori Elements (declarative via annotations)

#### Annotations System (`app/annotations.cds`)

**Key Annotation Types**:
- `@UI.LineItem`: Table columns
- `@UI.SelectionFields`: Filter bar fields
- `@UI.Facets`: Object page sections
- `@Aggregation.default: #SUM`: Analytical measures
- `@Analytics.Dimension`: Grouping dimensions

**Example**:
```cds
annotate AnalyticsService.FinancialStatements with @(
  UI.LineItem: [
    {Value: period, Label: 'Period'},
    {Value: account, Label: 'Account'},
    {Value: amount, Label: 'Amount'}
  ],
  UI.SelectionFields: [period, account]
);
```

#### Launchpad (`app/launchpad.html`)

Central entry point with tile navigation using semantic object-action pattern:
- `#financialstatements-display`
- `#revenueanalysis-display`
- `#workingcapital-display`

### 4. Integration Layer

#### dbt Pipeline (`../dbt/`)

**Pipeline Stages**:
1. **Staging** (`models/staging/`): Clean raw CSV/Excel data
   - Remove European number formatting (comma → decimal)
   - Standardize column names
   - Generate UUIDs

2. **Intermediate** (`models/intermediate/`): Business logic transformations
   - Revenue classification
   - Period calculations
   - Account aggregations

3. **Marts** (`models/marts/`): Analytics-ready datasets
   - `core/`: Products, orders, deliveries
   - `finance/`: Financial statements, revenue analysis, GL

**Export Process** (`export_to_sqlite.py`):
```python
# Reads dbt DuckDB output
# Writes to /root/projects/database/db.sqlite
# Table naming: demo.EntityName → demo_EntityName
```

#### Synchronization Points

**Critical**: Changes in dbt require corresponding CAP updates

1. **Schema Changes**:
   - Update dbt model → Update `db/schema.cds` entity
   - Add column → Add field to CDS entity + update annotations

2. **Business Logic**:
   - Revenue classification: `dbt/macros/categorize_revenue.sql` ↔ `srv/config/constants.js`
   - Period definitions: dbt intermediate models ↔ `srv/utils/period-utils.js`

3. **Data Refresh**:
   ```bash
   cd ../dbt && ./build.sh  # Full pipeline
   # CAP automatically picks up changes on next request (SQLite read)
   ```

## Technology Stack

### Backend
- **Framework**: SAP CAP v9.5.2 (Node.js)
- **Protocol**: OData V4
- **Database**: SQLite 3.x (production), in-memory (tests)
- **Authentication**: Mock users (alice, bob, charlie)
- **Logging**: Custom logger with Winston-style API

### Frontend
- **Framework**: SAP UI5 / Fiori Elements
- **UI Patterns**: Analytical List Page, List Report, Object Page
- **Templating**: Declarative (annotations-based)
- **Routing**: Fiori-managed (manifest.json)

### Data Pipeline
- **ETL**: dbt (Data Build Tool) 1.x
- **Source DB**: DuckDB (analytics-optimized)
- **Target DB**: SQLite (shared with CAP)
- **Languages**: SQL (dbt models), Python (export script)

### Testing
- **Backend**: Jest (80% coverage threshold)
- **Frontend E2E**: wdi5 (WebdriverIO for UI5)
- **Integration**: OPA5 (One Page Acceptance)
- **HTTP Testing**: supertest (OData endpoints)

### Deployment
- **Containerization**: Docker + docker-compose
- **Base Image**: Node.js Alpine
- **Volumes**: SQLite database mount
- **Ports**: 4004 (CAP), exposed via EXPOSE directive

## Data Flow

### End-to-End Pipeline

```
1. Data Ingestion
   └─→ Raw files in dbt/seeds/raw/ (CSV) and dbt/seeds/excel/ (XAF)
       └─→ dbt/seeds/clean_csvs.sh (European number formatting)

2. dbt Transformation
   └─→ dbt run --models staging (stg_*.sql)
       └─→ dbt run --models intermediate (int_*.sql)
           └─→ dbt run --models marts (mart_*.sql)

3. Database Export
   └─→ python3 export_to_sqlite.py
       └─→ /root/projects/database/db.sqlite

4. CAP Service
   └─→ CDS entities query SQLite
       └─→ Tree builders aggregate data
           └─→ OData V4 responses

5. Fiori UI
   └─→ OData binding in manifest.json
       └─→ UI5 controls render data
           └─→ User interactions
```

### Request Flow Example

**User Action**: "View Revenue Analysis for 2024"

```
1. UI Request
   GET /analytics/RevenueAnalysis?$filter=year eq 2024

2. CAP Service (srv/analytics-service.js)
   └─→ Query SQLite: SELECT * FROM demo_RevenueAnalysis WHERE year = 2024
   └─→ Result: [{accountCode: '80', amount: 50000, ...}, ...]

3. Tree Builder (if tree function called)
   └─→ getRevenueLTMTree(year, period, comparison)
   └─→ Classify accounts (ONE_OFF vs RECURRING)
   └─→ Build hierarchical structure
   └─→ Calculate watA/watB percentages
   └─→ Return JSON string

4. OData Response
   └─→ JSON with @odata.context
   └─→ Fiori Elements binds to table/chart

5. UI Rendering
   └─→ Analytical List Page displays:
       - Filter bar (year, period)
       - Chart (revenue trends)
       - Table (drilldown to accounts)
```

## Security Architecture

### Authentication
- **Mode**: Mock (development only)
- **Users**: Defined in `package.json` → `cds.requires.auth.users`
- **Credentials**: alice:alice, bob:bob, charlie:charlie
- **Production**: Replace with SAP BTP authentication or OAuth2

### Authorization
- **Service Level**: CAP annotations `@requires: 'authenticated-user'`
- **Entity Level**: CDS restrictions (not currently implemented)
- **Row Level**: Via user context (future enhancement)

### Data Validation
- **Input Sanitization**: `srv/utils/validation.js`
- **SQL Injection**: Protected by CDS query builder (parameterized queries)
- **XSS**: Fiori Elements automatic encoding

## Monitoring & Observability

### Application Monitoring
- **Middleware**: `srv/middleware/monitoring.js`
- **Metrics**: Request count, duration, errors
- **Slow Request Threshold**: 1000ms
- **Logging Interval**: 60 seconds
- **Test Mode**: Automatically disabled (NODE_ENV=test)

### Logging
- **Framework**: Custom logger (`srv/utils/logger.js`)
- **Levels**: error, warn, info, debug
- **Output**: Console (structured JSON in production)
- **Context**: Module name, timestamp, request ID

### Error Handling
- **Centralized**: `srv/utils/error-handler.js`
- **HTTP Mapping**: Business errors → 400, System errors → 500
- **Production Mode**: Sanitized error messages (no internal paths)

## Deployment Architecture

### Docker Container
```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --production
COPY . .
EXPOSE 4004
CMD ["npm", "start"]
```

### docker-compose.yml
```yaml
services:
  cds-cap:
    build: .
    ports:
      - "4004:4004"
    volumes:
      - /root/projects/database/db.sqlite:/app/db.sqlite
    environment:
      - NODE_ENV=production
```

**Volume Mount**: Ensures CAP reads from dbt-generated database

### Environment Variables
- `NODE_ENV`: production | development | test
- `PORT`: HTTP server port (default: 4004)
- `LOG_LEVEL`: error | warn | info | debug

## Performance Considerations

### Database Optimization
- **Indexes**: Defined in dbt models (not in CAP)
- **Query Patterns**: Projection-based (only requested fields)
- **Caching**: SQLite page cache (OS level)

### Tree Builder Performance
- **Lazy Loading**: Trees built on-demand per request
- **Aggregation**: Pre-aggregated in dbt marts when possible
- **Memory**: Recursive tree building (watch for deep hierarchies)

### Frontend Performance
- **Lazy Loading**: Fiori Elements pagination (OData $top/$skip)
- **Model Size**: Limit initial data load via default filters
- **Chart Rendering**: UI5 VizFrame optimizations

## Extension Points

### Adding New Entities
1. Create dbt model in `../dbt/models/marts/`
2. Run `./build.sh` to generate SQLite table
3. Add CDS entity to `db/schema.cds`
4. Expose in `srv/analytics-service.cds`
5. Create Fiori app with annotations in `app/annotations.cds`

### Custom Tree Builders
1. Create new builder in `srv/utils/`
2. Import shared utilities from `tree-builder-common.js`
3. Define function in `srv/analytics-service.cds`
4. Implement handler in `srv/analytics-service.js`
5. Add unit tests in `test/srv/utils/`

### New Fiori App
```bash
npx fiori generate app
# Choose template: Analytical List Page or List Report
# Configure OData service binding
# Add annotations in app/annotations.cds
```

## Known Limitations

1. **SQLite Concurrency**: Single-writer limitation (dbt has exclusive write access)
2. **Revenue Classification**: Manual sync required between dbt macro and CAP constants
3. **Mock Authentication**: Not suitable for production (use SAP BTP or OAuth2)
4. **Tree Depth**: Deep hierarchies (>10 levels) may cause performance issues
5. **Data Refresh**: Requires manual dbt pipeline run (no real-time updates)

## Future Architecture Enhancements

### Planned Improvements
- [ ] Replace SQLite with PostgreSQL or SAP HANA Cloud (multi-writer support)
- [ ] Implement Redis caching layer for tree builder results
- [ ] Add WebSocket support for real-time data updates
- [ ] Migrate to SAP BTP Cloud Foundry deployment
- [ ] Implement row-level security based on user context
- [ ] Add GraphQL API layer alongside OData

### Under Consideration
- [ ] Event-driven architecture (trigger CAP refresh on dbt completion)
- [ ] Separate read replicas for analytics queries
- [ ] Materialized views for complex tree structures
- [ ] API Gateway with rate limiting and authentication
- [ ] Kubernetes deployment with horizontal scaling

## Related Documentation

- [README.md](../README.md) - Getting started and project overview
- [AUTHENTICATION.md](../AUTHENTICATION.md) - Authentication setup
- [srv/utils/README.md](../srv/utils/README.md) - Utility module documentation
- [test/README.md](../test/README.md) - Testing strategy and execution
- [../dbt/README.md](../../dbt/README.md) - dbt pipeline architecture
- [../dbt/HANDOFF.md](../../dbt/HANDOFF.md) - dbt implementation history
